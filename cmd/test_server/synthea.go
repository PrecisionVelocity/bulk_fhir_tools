// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"errors"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	syntheaGroupID   = "group_id_synthea"
	syntheaTimeStamp = "20230222T150000Z"
)

// loadSynthea downloads a zip file of synthetic FHIR data generated by the Synthea
// Patient Generator, converts it to ndjson and saves it in the
// dataDir/group_id_synthea/20230222T150000Z.
//  1. Download the zip file of Synthea generated FHIR data and temporarily save
//     it in {--data_dir}/group_id_synthea/20230222T150000Z. group_id_synthea
//     and 20230222T150000Z folders will be created if they do not already exist
//     in --data_dir.
//  2. Unzip the folder and convert the R4 FHIR transaction bundles to FHIR
//     ndjson format. rowsPerNDJSON determines the number of FHIR resources per
//     ndjson and outputFolder determines where the ndjson is saved.
//  3. Delete the temporary zip file.
//
// URL should be https://github.com/synthetichealth/synthea-sample-data/raw/master/downloads/synthea_sample_data_fhir_r4_nov2021.zip
// except for testing.
func loadSynthea(url, dataDir string, rowsPerNDJSON int) error {
	syntheaDir := filepath.Join(dataDir, syntheaGroupID, syntheaTimeStamp)
	log.Printf("Creating folders for Synthea synthetic FHIR data: %s\n", syntheaDir)
	if err := os.MkdirAll(syntheaDir, 0755); err != nil {
		return err
	}
	tempZipDir, err := os.MkdirTemp(syntheaDir, "*-TempSyntheaZip")
	if err != nil {
		return err
	}
	tempZipPath := filepath.Join(tempZipDir, "temp_synthea.zip")

	log.Println("Downloading Synthea synthetic FHIR zip file.")
	if err := downloadZip(url, tempZipPath); err != nil {
		return err
	}

	log.Println("Download complete. Converting Synthea FHIR Bundles to NDJSON.")
	if err := convertBundles(tempZipPath, syntheaDir, rowsPerNDJSON); err != nil {
		return err
	}

	log.Println("Conversion complete. Cleaning up temporary zip file.")
	if err := os.RemoveAll(tempZipDir); err != nil {
		return err
	}
	log.Printf("Successfully loaded Synthea synthetic FHIR data into %s\n", syntheaDir)
	return nil
}

func downloadZip(url, zipPath string) (err error) {
	z, err := os.Create(zipPath)
	if err != nil {
		return err
	}
	defer func() {
		if tempErr := z.Close(); tempErr != nil && err == nil {
			err = tempErr
		}
	}()

	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer func() {
		if tempErr := resp.Body.Close(); tempErr != nil && err == nil {
			err = tempErr
		}
	}()

	_, err = io.Copy(z, resp.Body)
	if err != nil {
		return err
	}
	return err
}

type resource struct {
	ResourceType string `json:"resourceType"`
}

type entry struct {
	Resource json.RawMessage `json:"resource"`
}

type bundle struct {
	Entry []entry `json:"entry"`
}

func convertBundles(zipPath, outputFolder string, rowsPerNDJSON int) (err error) {
	zr, err := zip.OpenReader(zipPath)
	if err != nil {
		return err
	}
	defer func() {
		if tempErr := zr.Close(); tempErr != nil && err == nil {
			err = tempErr
		}
	}()

	ndjsonW, err := newNDJSONWriter(outputFolder, rowsPerNDJSON)
	if err != nil {
		return err
	}
	for _, f := range zr.File {
		if f.FileInfo().IsDir() || !strings.HasSuffix(f.Name, ".json") {
			continue
		}
		log.Printf("Converting file: %s\n", f.Name)
		fr, err := f.Open()
		if err != nil {
			return err
		}
		b, err := io.ReadAll(fr)
		if err != nil {
			return err
		}
		var bund bundle
		if err = json.Unmarshal(b, &bund); err != nil {
			return err
		}
		for _, e := range bund.Entry {
			if err = ndjsonW.write(e); err != nil {
				return err
			}
		}
		if err = fr.Close(); err != nil {
			return err
		}
	}

	if err = ndjsonW.close(); err != nil {
		return err
	}
	return err
}

type ndjsonWriter struct {
	// Maps FHIR resource type to a count of the total number of that resource type processed.
	count map[string]int
	// Maps FHIR resource type to a buffer of the current ndjson file. Buffer is
	// written to disk and cleared whenever there are rowsPerNDJSON's in the
	// buffer.
	buf           map[string]*bytes.Buffer
	outputFolder  string
	rowsPerNDJSON int
}

func newNDJSONWriter(outputFolder string, rowsPerNDJSONFile int) (*ndjsonWriter, error) {
	if rowsPerNDJSONFile <= 0 {
		return nil, errors.New("rowsPerNDJSONFile must be greater than 0")
	}
	return &ndjsonWriter{
		count:         make(map[string]int),
		buf:           make(map[string]*bytes.Buffer),
		outputFolder:  outputFolder,
		rowsPerNDJSON: rowsPerNDJSONFile}, nil
}

func (n *ndjsonWriter) write(e entry) error {
	var resource resource
	if err := json.Unmarshal(e.Resource, &resource); err != nil {
		return err
	}
	resourceType := resource.ResourceType

	if n.buf[resourceType] == nil {
		n.buf[resourceType] = new(bytes.Buffer)
	}

	b, err := json.Marshal(e.Resource)
	if err != nil {
		return err
	}
	if err := json.Compact(n.buf[resourceType], b); err != nil {
		return err
	}
	n.count[resourceType]++

	// Write out buf and clear if we reached rowsPerNDJSON in the buf.
	if n.count[resourceType]%n.rowsPerNDJSON == 0 {
		index := (n.count[resourceType] / n.rowsPerNDJSON) - 1 // Floor division - 1
		fileName := resourceType + "_" + strconv.Itoa(index) + ".ndjson"

		if err := os.WriteFile(filepath.Join(n.outputFolder, fileName), n.buf[resourceType].Bytes(), 0644); err != nil {
			return err
		}
		n.buf[resourceType].Reset()
		return nil
	}

	n.buf[resourceType].WriteString("\n")
	return nil
}

func (n *ndjsonWriter) close() error {
	for f, b := range n.buf {
		if b.Len() == 0 {
			continue
		}
		index := n.count[f] / n.rowsPerNDJSON // Floor division
		fileName := f + "_" + strconv.Itoa(index) + ".ndjson"
		if err := os.WriteFile(filepath.Join(n.outputFolder, fileName), bytes.TrimSuffix(b.Bytes(), []byte("\n")), 0644); err != nil {
			return err
		}
	}
	return nil
}
